#!/bin/bash
# Startup script for web instances:
# - Installs Docker
# - Waits for MongoDB connectivity on the private network
# - Runs API container (localhost:3000)
# - Runs Frontend container (localhost:5000)
# - Runs Nginx reverse proxy (public :80)
#
# LB -> :80 (nginx) -> /api -> API, / -> Frontend

exec > >(tee -a /var/log/startup-script.log) 2>&1
set -euxo pipefail

export DEBIAN_FRONTEND=noninteractive

apt-get update
apt-get install -y docker.io netcat

systemctl enable docker
systemctl start docker

# Allow the SSH user to run docker without sudo (requires new login session to take effect)
usermod -aG docker '${ssh_username}' || true

# Wait for Docker socket (sometimes the service is "started" but socket isn't ready yet)
for i in $(seq 1 30); do
  if docker info >/dev/null 2>&1; then
    break
  fi
  echo "Waiting for Docker daemon... ($i/30)"
  sleep 2
done

DB_HOST='${mongo_private_ip}'
DB_PORT='27017'

echo "Waiting for MongoDB at $DB_HOST:$DB_PORT ..."
for i in $(seq 1 60); do
  if nc -z "$DB_HOST" "$DB_PORT"; then
    echo "MongoDB is reachable!"
    break
  fi
  echo "MongoDB not ready yet ($i/60). Sleeping 5s..."
  sleep 5
done

# Do not hard-fail the VM if Mongo is still not reachable; the API might still start.
nc -z "$DB_HOST" "$DB_PORT" || echo "MongoDB still not reachable; continuing anyway..."

# Create shared Docker network so containers can talk by name
docker network create todo-net || true

# --- Run API (localhost:3000) ---
docker rm -f todo-api || true
docker pull ${api_image} || true

MONGO_URI="mongodb://${mongo_root_username}:${mongo_root_password}@$DB_HOST:$DB_PORT/todo_api?authSource=admin"
docker run -d --name todo-api \
  --restart unless-stopped \
  --network todo-net \
  -e MONGODB_URI="$MONGO_URI" \
  -e PORT='${api_container_port}' \
  -e NODE_ENV=development \
  -e LOG_LEVEL=debug \
  ${api_image}

echo "todo-api container started."

# --- Run Frontend (localhost:5000 -> container:80) ---
docker rm -f todo-app || true
docker pull ${frontend_image} || true

docker run -d --name todo-app \
  --restart unless-stopped \
  --network todo-net \
  ${frontend_image}

echo "todo-app container started."

# --- Nginx reverse proxy on :80 (public) ---
mkdir -p /opt/todo-nginx

cat >/opt/todo-nginx/nginx.conf <<'EOF'
worker_processes auto;

events {
  worker_connections 2048;
}

http {
  include /etc/nginx/mime.types;
  default_type application/octet-stream;

  upstream apiServers {
    server todo-api:${api_container_port} fail_timeout=30s max_fails=3;
    keepalive 16;
  }

  upstream frontendServers {
    server todo-app:${frontend_container_port} fail_timeout=30s max_fails=3;
    keepalive 16;
  }

  server {
    listen 80;
    server_name _;

    location = /health {
      add_header Content-Type application/json;
      return 200 '{"status":"ok"}';
    }

    location /api/ {
      proxy_pass http://apiServers;
      proxy_http_version 1.1;
      proxy_set_header Host $host;
      proxy_set_header X-Real-IP $remote_addr;
      proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
      proxy_set_header X-Forwarded-Proto $scheme;
    }

    location / {
      proxy_pass http://frontendServers;
      proxy_http_version 1.1;
      proxy_set_header Host $host;
      proxy_set_header X-Real-IP $remote_addr;
      proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
      proxy_set_header X-Forwarded-Proto $scheme;
    }
  }
}
EOF

docker rm -f todo-nginx || true
docker pull nginx:alpine || true

docker run -d --name todo-nginx \
  --restart unless-stopped \
  --network todo-net \
  -p 80:80 \
  -v /opt/todo-nginx/nginx.conf:/etc/nginx/nginx.conf:ro \
  nginx:alpine

echo "Nginx is running on :80. API: /api/, Frontend: /"
